<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>i5ting_ztree_toc:JavaScript高级</title>
  <link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet"
    type="text/css" />
  <link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet"
    type="text/css" />
  <link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css" />
  <style>
    pre {
      counter-reset: line-numbering;
      border: solid 1px #d9d9d9;
      border-radius: 0;
      background: #fff;
      padding: 0;
      line-height: 23px;
      margin-bottom: 30px;
      white-space: pre;
      overflow-x: auto;
      word-break: inherit;
      word-wrap: inherit;
    }

    pre a::before {
      content: counter(line-numbering);
      counter-increment: line-numbering;
      padding-right: 1em;
      /* space after numbers */
      width: 25px;
      text-align: right;
      opacity: 0.7;
      display: inline-block;
      color: #aaa;
      background: #eee;
      margin-right: 16px;
      padding: 2px 10px;
      font-size: 13px;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    pre a:first-of-type::before {
      padding-top: 10px;
    }

    pre a:last-of-type::before {
      padding-bottom: 10px;
    }

    pre a:only-of-type::before {
      padding: 10px;
    }

    .highlight {
      background-color: #ffffcc
    }

    /* RIGHT */
  </style>
</head>

<body>
  <div>
    <div style='width:25%;'>
      <ul id="tree" class="ztree" style='width:100%'>

      </ul>
    </div>
    <div id='readme' style='width:70%;margin-left:20%;'>
      <article class='markdown-body'>
        <h2 id="-">面向过程与面向对象</h2>
        <h3 id="-">面向过程</h3>
        <ul>
          <li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</li>
        </ul>
        <h3 id="-">面向对象</h3>
        <ul>
          <li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</li>
          <li>特性：封装性，继承性，多态性 </li>
        </ul>
        <h3 id="-">面向过程与面向对象对比</h3>
        <table>
          <thead>
            <tr>
              <th></th>
              <th>面向过程</th>
              <th>面向对象</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>优点</td>
              <td>性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</td>
              <td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td>
            </tr>
            <tr>
              <td>缺点</td>
              <td>不易维护、不易复用、不易扩展</td>
              <td>性能比面向过程低</td>
            </tr>
          </tbody>
        </table>
        <h2 id="-">对象与类</h2>
        <h3 id="-">对象</h3>
        <p>对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物</p>
        <ul>
          <li>属性：事物的特征，在对象中用属性来表示（常用名词）</li>
          <li>方法：事物的行为，在对象中用方法来表示（常用动词）</li>
        </ul>
        <p>1.</p>
        <h4 id="-">创建对象</h4>
        <pre><code class="lang-js">//以下代码是对对象的复习
//字面量创建对象
var ldh = {
    name: &#39;刘德华&#39;,
    age: 18
}
console.log(ldh);

//构造函数创建对象
  function Star(name, age) {
    this.name = name;
    this.age = age;
 }
var ldh = new Star(&#39;刘德华&#39;, 18)//实例化对象
console.log(ldh);    
</code></pre>
        <h3 id="-">类</h3>
        <ul>
          <li>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象</li>
        </ul>
        <h4 id="-">创建类</h4>
        <ol>
          <li>语法:</li>
        </ol>
        <pre><code class="lang-js">//步骤1 使用class关键字
class name {
  // class body
}     
//步骤2使用定义的类创建实例  注意new关键字
var xx = new name();     
</code></pre>
        <ol start="2">
          <li>示例</li>
        </ol>
        <pre><code class="lang-js"> // 1. 创建类 class  创建一个 明星类
 class Star {
   // 类的共有属性放到 constructor 里面
   constructor(name, age) {
   this.name = name;
   this.age = age;
   }
 }
   // 2. 利用类创建对象 new
   var ldh = new Star(&#39;刘德华&#39;, 18);
   console.log(ldh);
</code></pre>
        <p>通过结果我们可以看出,运行结果和使用构造函数方式一样</p>
        <h4 id="-">类创建添加属性和方法</h4>
        <pre><code class="lang-js"> // 1. 创建类 class  创建一个类
class Star {
    // 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数
    constructor(uname, age) {
      this.uname = uname;
      this.age = age;
    }//-------------------------------------------&gt;注意,方法与方法之间不需要添加逗号
    sing(song) {
      console.log(this.uname + &#39;唱&#39; + song);
    }
}
// 2. 利用类创建对象 new
var ldh = new Star(&#39;刘德华&#39;, 18);
console.log(ldh); // Star {uname: &quot;刘德华&quot;, age: 18}
ldh.sing(&#39;冰雨&#39;); // 刘德华唱冰雨
</code></pre>
        <p><strong>注意哟:</strong></p>
        <ol>
          <li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li>
          <li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li>
          <li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</li>
          <li>多个函数方法之间不需要添加逗号分隔</li>
          <li>生成实例 new 不能省略</li>
          <li>语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</li>
        </ol>
        <h4 id="-">类的继承</h4>
        <ol>
          <li>语法</li>
        </ol>
        <pre><code class="lang-js">// 父类
class Father{   
} 

// 子类继承父类
class  Son  extends Father {  
}       
</code></pre>
        <ol start="2">
          <li>示例</li>
        </ol>
        <pre><code class="lang-js">class Father {
      constructor(surname) {
        this.surname= surname;
      }
      say() {
        console.log(&#39;你的姓是&#39; + this.surname);
       }
}

class Son extends Father{  // 这样子类就继承了父类的属性和方法
}
var damao= new Son(&#39;刘&#39;);
damao.say();      //结果为 你的姓是刘
</code></pre>
        <ul>
          <li>
            <p>子类使用super关键字访问父类的方法</p>
            <pre><code class="lang-js">//定义了父类
class Father {
   constructor(x, y) {
   this.x = x;
   this.y = y;
   }
   sum() {
   console.log(this.x + this.y);
    }
 }
//子元素继承父类
    class Son extends Father {
            constructor(x, y) {
            super(x, y); //使用super调用了父类中的构造函数
        }
    }
    var son = new Son(1, 2);
    son.sum(); //结果为3
</code></pre>
            <p><strong>注意:</strong> </p>
            <ol>
              <li>
                <p>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</p>
              </li>
              <li>
                <p>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</p>
              </li>
              <li>
                <p>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用</p>
                <pre><code class="lang-js"> // 父类有加法方法
 class Father {
   constructor(x, y) {
   this.x = x;
   this.y = y;
   }
   sum() {
   console.log(this.x + this.y);
   }
 }
 // 子类继承父类加法方法 同时 扩展减法方法
 class Son extends Father {
   constructor(x, y) {
   // 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错
   super(x, y);
   this.x = x;
   this.y = y;

  }
  subtract() {
  console.log(this.x - this.y);
  }
}
var son = new Son(5, 3);
son.subtract(); //2
son.sum();//8
</code></pre>
              </li>
              <li>
                <p>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</p>
                <ol>
                  <li>constructor中的this指向的是new出来的实例对象 </li>
                  <li>自定义的方法,一般也指向的new出来的实例对象</li>
                  <li>绑定事件之后this指向的就是触发事件的事件源</li>
                </ol>
              </li>
              <li>
                <p>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p>
              </li>
            </ol>
          </li>
        </ul>
        <h2 id="-tab-">面向对象版tab 栏切换</h2>
        <h3 id="-">功能需求</h3>
        <ol>
          <li>点击 tab栏,可以切换效果.</li>
          <li>点击 + 号, 可以添加 tab 项和内容项.</li>
          <li>点击 x 号, 可以删除当前的tab项和内容项.</li>
          <li>双击tab项文字或者内容项文字可以修改里面的文字内容</li>
        </ol>
        <h3 id="-">案例准备</h3>
        <ol>
          <li>获取到标题元素</li>
          <li>获取到内容元素</li>
          <li>获取到删除的小按钮 x号</li>
          <li>新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改)</li>
          <li>时刻注意this的指向问题</li>
        </ol>
        <h3 id="-">切换</h3>
        <ul>
          <li>
            <p>为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引</p>
            <pre><code class="lang-js"> this.lis[i].index = i;
 this.lis[i].onclick = this.toggleTab;
</code></pre>
          </li>
          <li>
            <p>使用排他,实现只有一个元素的显示</p>
            <pre><code class="lang-js"> toggleTab() {
   //将所有的标题与内容类样式全部移除
     for (var i = 0; i &lt; this.lis.length; i++) {
     this.lis[i].className = &#39;&#39;;
     this.sections[i].className = &#39;&#39;;
     }
   //为当前的标题添加激活样式
     this.className = &#39;liactive&#39;;
    //为当前的内容添加激活样式
     that.sections[this.index].className = &#39;conactive&#39;;
  }
</code></pre>
          </li>
        </ul>
        <h3 id="-">添加</h3>
        <ul>
          <li>
            <p>为添加按钮+ 绑定点击事件 </p>
            <pre><code class="lang-js"> this.add.onclick = this.addTab;
</code></pre>
          </li>
          <li>
            <p>实现标题与内容的添加,做好排他处理</p>
            <pre><code class="lang-js">addTab() {
    that.clearClass();
    // (1) 创建li元素和section元素 
    var random = Math.random();
    var li = &#39;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;                &lt;/span&gt;&lt;/li&gt;&#39;;
    var section = &#39;&lt;section class=&quot;conactive&quot;&gt;测试 &#39; + random + &#39;&lt;/section&gt;&#39;;
    // (2) 把这两个元素追加到对应的父元素里面
    that.ul.insertAdjacentHTML(&#39;beforeend&#39;, li);
    that.fsection.insertAdjacentHTML(&#39;beforeend&#39;, section);
    that.init();
    }
</code></pre>
          </li>
        </ul>
        <h3 id="-">删除</h3>
        <ul>
          <li>
            <p>为元素的删除按钮x绑定点击事件</p>
            <pre><code class="lang-js"> this.remove[i].onclick = this.removeTab;
</code></pre>
          </li>
          <li>
            <p>获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容</p>
            <pre><code class="lang-js"> removeTab(e) {
     e.stopPropagation(); // 阻止冒泡 防止触发li 的切换点击事件
     var index = this.parentNode.index;
     console.log(index);
     // 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素
     that.lis[index].remove();
     that.sections[index].remove();
     that.init();
     // 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变
     if (document.querySelector(&#39;.liactive&#39;)) return;
     // 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态
     index--;
     // 手动调用我们的点击事件  不需要鼠标触发
     that.lis[index] &amp;&amp; that.lis[index].click();
 }
</code></pre>
          </li>
        </ul>
        <h3 id="-">编辑</h3>
        <ul>
          <li>
            <p>为元素(标题与内容)绑定双击事件</p>
            <pre><code class="lang-js"> this.spans[i].ondblclick = this.editTab;
 this.sections[i].ondblclick = this.editTab;
</code></pre>
          </li>
          <li>
            <p>在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递</p>
            <pre><code class="lang-js">editTab() {
    var str = this.innerHTML;
    // 双击禁止选定文字
    window.getSelection ? window.getSelection().removeAllRanges() :                     document.selection.empty();
    // alert(11);
      this.innerHTML = &#39;&lt;input type=&quot;text&quot; /&gt;&#39;;
      var input = this.children[0];
      input.value = str;
      input.select(); // 文本框里面的文字处于选定状态
      // 当我们离开文本框就把文本框里面的值给span 
      input.onblur = function() {
      this.parentNode.innerHTML = this.value;
      };
      // 按下回车也可以把文本框里面的值给span
      input.onkeyup = function(e) {
      if (e.keyCode === 13) {
      // 手动调用表单失去焦点事件  不需要鼠标离开操作
      this.blur();
      }
    }
}
</code></pre>
          </li>
        </ul>
        <blockquote>
          <p>主要内容：</p>
          <p>ES5面向对象核心概念:构造函数和原型对象</p>
          <p>利用构造函数和原型对象实现继承</p>
          <p>ES5新增方法</p>
        </blockquote>
        <h2 id="-">构造函数和原型</h2>
        <h3 id="-">构造函数</h3>
        <p>问题:</p>
        <ol>
          <li>构造函数的作用？有什么缺点? </li>
          <li>何谓实例成员？何谓静态成员？</li>
        </ol>
        <p>答:</p>
        <ol>
          <li>作用：创建对象，缺点:在构造函数中定义方法时，每个实例的方法都会独占一块内存，浪费资源。</li>
          <li>在构造函数中设置在this上的属性被称为实例成员，直接设置在构造函数上的属性被称为静态成员。</li>
        </ol>
        <h3 id="-">原型对象</h3>
        <p>问题:</p>
        <ol>
          <li>原型对象有何作用? 让实例可以共享方法，弥补构造函数的不足</li>
          <li>如何访问原型对象? </li>
        </ol>
        <pre><code class="lang-js">// 构造函数.prototype   或  实例.__proto__
function Fn()
var f1 = new Fn()
console.log(Fn.prototype) // {constructor:Fn,__proto__:{...}}
console.log(Fn.prototype===f1.__proto__) // true
</code></pre>
        <ol start="3">
          <li>原型对象最少包含哪些属性? </li>
        </ol>
        <pre><code class="lang-js">至少包含 constructor __proto__ 两个属性
</code></pre>
        <h3 id="-">构造函数、原型对象、实例之间的关系</h3>
        <img src="./toc/images/img4.png" alt="">
        <h3 id="-">原型链</h3>
        <img src="./toc/images/img5.png" alt="">

        <p><code>所有对象均有原型对象，原型对象也有自己的原型对象，依次类推，构成了一条原型对象的链条，被称为原型链</code></p>
        <p><code>构成原型链的属性是__proto__,原型链的终点为null</code></p>
        <p><code>原型链上的所有属性均可被实例对象共享</code></p>
        <pre><code class="lang-js">// __ptoto__及prototype区分
所有对象都有__proto__,只有函数对象才有prototype
对象 可分为两大类:函数对象  及 非函数对象
所有函数(包括Object Array  Date...)均可视为 Function 的实例,Function是它自己的实例
Function.__proto__==Function.prototype //true
</code></pre>
        <h3 id="-">对象成员查找规则</h3>
        <p>沿原型链逐层查找，就近原则，都查不到时返回undefined。</p>
        <pre><code class="lang-js">function F(){
}
F.prototype.sex = &#39;male&#39;
var f1 = new F()
console.log(f1.sex) // male ?

function F(name,sex){
    this.name = name;
    this.sex = sex;
}
F.prototype.sex = &#39;male&#39;
var f1 = new F(&#39;Lucy&#39;,20)
console.log(f1.sex) // 20
</code></pre>
        <h3 id="-this-">原型对象方法中this指向</h3>
        <p>谁调用，指向谁</p>
        <h3 id="-">利用原型对象扩展内置对象方法</h3>
        <pre><code class="lang-js">//为数组增加求最大值方法
Array.prototype.max = function(){
    var tmp = this[0]
    for(var i=1;i&lt;this.length;i++){
        if(tmp&lt;this[i]){
            tmp = this[i]
        }
    }
    return tmp;
}
[1,20,4].max() // 20
</code></pre>
        <h2 id="-">利用构造函数和原型实现继承</h2>
        <h3 id="-">继承有什么作用?</h3>
        <p><em>继承发生在类之间，子类继承父类时，子类的实例中会包含父类中的所有属性及方法，利用继承可方便地实现代码复用</em></p>
        <h3 id="call-">call方法使用</h3>
        <p>问题:</p>
        <p>1 call方法对哪些对象有效?</p>
        <p>2 call方法有什么作用？</p>
        <pre><code class="lang-js">// call方法功能：
// 1. 调用函数
// 2. 改变this指向，间接也扩大了函数的有效范围
// 注意：仅函数对象能调用call方法
// 使用方法 函数.call(对象，参数列表)
var o1 = {name:&#39;jim&#39;,test:function(){alert(this.name)}}
o1.test() // jim
var o2 = {name:&#39;Bill&#39;}
o1.test.call(o2)

function test(){
   // return arguments.slice(1)  会报错，arguments为伪数组，没有slice方法
   return Array.prototype.slice.call(arguments,1)
}
test(1,2,3) //[2,3]
</code></pre>
        <h3 id="-">利用构造函数实现属性继承</h3>
        <pre><code class="lang-js">function Father(name,age){
    this.name = name;
    this.age = age;
}
Father.prototype.sing = function(){
    console.log(&#39;唱歌&#39;)
}
function Son(name,age,grade){
    Father.call(this,name,age)
    this.grade = grade;
}
var s1 = new Son(&#39;张三&#39;,20,9)
console.log(s1)
</code></pre>
        <h3 id="-">利用原型实现方法继承</h3>
        <pre><code class="lang-js">Son.prototype = new Father()
Son.prototype.constructor = Son;
s1.sing()
</code></pre>
        <h3 id="-">研究类的本质</h3>
        <ul>
          <li>ES6中的class就相当于是ES5中的构造函数</li>
          <li>定义在class中的方法其实都被存放在class的prototype中</li>
          <li>直接往class的prototype中添加的方法也可以被所有class的实例共享</li>
        </ul>
        <h2 id="es5-">ES5新增方法</h2>
        <h3 id="-">数组相关</h3>
        <table>
          <thead>
            <tr>
              <th>方法名</th>
              <th>功能</th>
              <th>使用方法</th>
              <th>备注</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>forEach</td>
              <td>遍历数组</td>
              <td>[1,2,3].forEach(function(ele,i,arr){console.log(ele,i,arr)})</td>
              <td>没有返回值</td>
            </tr>
            <tr>
              <td>filter</td>
              <td>过滤数组</td>
              <td>[1,2,3].filter(function(ele,i,arr){return ele&gt;1}) //[2,3]</td>
              <td>返回新数组</td>
            </tr>
            <tr>
              <td>some</td>
              <td>判断数组中是否有满足条件的元素</td>
              <td>[1,2,3].some(function(ele){return ele&gt;1}) //true</td>
              <td>返回true/false</td>
            </tr>
            <tr>
              <td>every</td>
              <td>判断数组中是否所有元素都满足条件</td>
              <td>[1,2,3].every(function(ele){return ele&gt;1}) //false</td>
              <td>返回true/false</td>
            </tr>
            <tr>
              <td>map</td>
              <td>数组映射</td>
              <td>[1,2,3].map(function(ele){return ele*2}) //[2 4 6]</td>
              <td>返回新数组</td>
            </tr>
            <tr>
              <td>reduce</td>
              <td>数组归纳</td>
              <td>[1,2,3].reduce(function(pre,cur){return pre+cur }) //6</td>
              <td>返回一个值</td>
            </tr>
          </tbody>
        </table>
        <h4 id="reduce-">reduce介绍</h4>
        <pre><code class="lang-js">// 语法:arr.reduce(callback,[initialValue])
// callback （执行数组中每个值的函数，包含四个参数）
// 1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
// 2、currentValue （数组中当前被处理的元素）
// 3、index （当前元素在数组中的索引）
// 4、array （调用 reduce 的数组）

// initialValue （作为第一次调用 callback 的第一个参数。）
var arr = [1, 2, 3, 4];
var sum = arr.reduce(function(prev, cur, index, arr) {
    console.log(prev, cur, index);
    return prev + cur;
})
console.log(arr, sum);
打印结果：
1 2 1
3 3 2
6 4 3
[1, 2, 3, 4] 10

可以看出，上面的例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。
// 高级用法-统计数组元素出现次数
var names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];
var nameNum = names.reduce(function(pre,cur){
  if(cur in pre){
    pre[cur]++
  }else{
    pre[cur] = 1 
  }
  return pre
},{})
console.log(nameNum); // {Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}
</code></pre>
        <h3 id="-">字符串相关</h3>
        <pre><code>// trim()方法可以去掉字符串两边的空格
&#39;  a b c   &#39;.trim() // &#39;a b c&#39;
</code></pre>
        <h3 id="-">对象相关</h3>
        <table>
          <thead>
            <tr>
              <th>方法名</th>
              <th>功能</th>
              <th>使用方法</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Object.keys()</td>
              <td>获取对象的所有属性名</td>
              <td>Object.keys({a:1,b:2})//[&#39;a&#39;,&#39;b&#39;]</td>
            </tr>
            <tr>
              <td>Object.values()</td>
              <td>获取对象的所有属性值</td>
              <td>Object.values({a:1,b:2})//[1,2]</td>
            </tr>
            <tr>
              <td>Object.defineProperty()</td>
              <td>新增/设置对象属性</td>
              <td>
                Object.defineProperty(obj,attr,{<br />value:xxx,<br />writable:false/true,<br />enumerable:false/true,<br />configurable:false/true})
              </td>
            </tr>
          </tbody>
        </table>
        <p>writable:是否可写 enumerable:是否可枚举 configurable:是否可删除及重新设置 ,使用defineProperty设置时，它们的默认值均为false</p>
        <p># </p>
        <h2 id="-">函数的定义和调用</h2>
        <h3 id="-">函数的定义方式</h3>
        <ol>
          <li>函数声明方式（命名函数）</li>
        </ol>
        <pre><code class="lang-js">function fn() {}
</code></pre>
        <ol start="2">
          <li>函数表达式（匿名函数）</li>
        </ol>
        <pre><code class="lang-js">var fn = function () {};
</code></pre>
        <ol start="3">
          <li>利用 new function（‘参数一’，‘参数二’，‘函数体’）</li>
        </ol>
        <pre><code class="lang-js">var f = new Function(&quot;a&quot;, &quot;b&quot;, &quot;console.log(a + b)&quot;);
f(1, 2);
</code></pre>
        <ul>
          <li>
            <p>Function 里面参数都必须是字符串格式</p>
          </li>
          <li>
            <p>第三种方式执行效率低，也不方便书写，因此较少使用</p>
          </li>
          <li>
            <p>所有函数都是 Function 的实例(对象)</p>
          </li>
          <li>
            <p>函数也属于对象</p>
          </li>
        </ul>
        <h3 id="-">函数的调用方式</h3>
        <ol>
          <li>普通函数</li>
        </ol>
        <pre><code class="lang-js">function fn() {
  console.log(&quot;人生的巅峰&quot;);
}
// fn();   fn.call()
</code></pre>
        <ol start="2">
          <li>对象的方法</li>
        </ol>
        <pre><code class="lang-js">var o = {
  sayHi: function () {
    console.log(&quot;人生的巅峰&quot;);
  },
};
o.sayHi();
</code></pre>
        <ol start="3">
          <li>构造函数</li>
        </ol>
        <pre><code class="lang-js">function Star() {}
new Star();
</code></pre>
        <ol start="4">
          <li>绑定事件函数</li>
        </ol>
        <pre><code class="lang-js">btn.onclick = function () {}; // 点击了按钮就可以调用这个函数
</code></pre>
        <ol start="5">
          <li>定时器函数</li>
        </ol>
        <pre><code class="lang-js">setInterval(function () {}, 1000); //这个函数是定时器自动 1 秒钟调用一次
</code></pre>
        <ol start="6">
          <li>立即执行函数</li>
        </ol>
        <pre><code class="lang-js">(function () {
  console.log(&quot;人生的巅峰&quot;);
})();
// 立即执行函数是自动调用
</code></pre>
        <h2 id="this-">this 指向问题</h2>
        <h3 id="-this-">函数内部的 this 指向</h3>
        <table>
          <thead>
            <tr>
              <th></th>
              <th></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td></td>
              <td></td>
            </tr>
            <tr>
              <td></td>
            </tr>
          </tbody>
        </table>
        <ol>
          <li>普通函数 this 指向 window</li>
        </ol>
        <pre><code class="lang-js">function fn() {
  console.log(&quot;普通函数的this&quot; + this);
}
window.fn();
</code></pre>
        <ol start="2">
          <li>对象的方法 this 指向的是对象 o</li>
        </ol>
        <pre><code class="lang-js">var o = {
  sayHi: function () {
    console.log(&quot;对象方法的this:&quot; + this);
  },
};
o.sayHi();
</code></pre>
        <ol start="3">
          <li>构造函数 this 指向 ldh 这个实例对象 原型对象里面的 this 指向的也是 ldh 这个实例对象</li>
        </ol>
        <pre><code class="lang-js">function Star() {}
Star.prototype.sing = function () {};
var ldh = new Star();
</code></pre>
        <ol start="4">
          <li>绑定事件函数 this 指向的是函数的调用者 btn 这个按钮对象</li>
        </ol>
        <pre><code class="lang-js">var btn = document.querySelector(&quot;button&quot;);
btn.onclick = function () {
  console.log(&quot;绑定时间函数的this:&quot; + this);
};
</code></pre>
        <ol start="5">
          <li>定时器函数 this 指向的也是 window</li>
        </ol>
        <pre><code class="lang-js">window.setTimeout(function () {
  console.log(&quot;定时器的this:&quot; + this);
}, 1000);
</code></pre>
        <ol start="6">
          <li>立即执行函数 this 还是指向 window</li>
        </ol>
        <pre><code class="lang-js">(function () {
  console.log(&quot;立即执行函数的this&quot; + this);
})();
</code></pre>
        <h3 id="-this-">改变函数内部 this 指向</h3>
        <h4 id="call-">call 方法</h4>
        <ol>
          <li>可以调用函数</li>
          <li>可以改变函数内的 this 指向</li>
          <li>主要作用可以实现继承</li>
        </ol>
        <h4 id="apply-">apply()方法</h4>
        <ol>
          <li>
            <p>调用函数 可以改变函数内部的 this 指向</p>
          </li>
          <li>
            <p>但是他的参数必须是数组(伪数组)</p>
          </li>
          <li>
            <p>apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值</p>
          </li>
        </ol>
        <pre><code class="lang-js">var o = {
  name: &quot;andy&quot;,
};
function fn(arr) {
  console.log(this);
  console.log(arr); // &#39;pink&#39;
}
fn.apply(o, [&quot;pink&quot;]);
var arr = [1, 66, 3, 99, 4];
var arr1 = [&quot;red&quot;, &quot;pink&quot;];
// var max = Math.max.apply(null, arr);
var max = Math.max.apply(Math, arr);
var min = Math.min.apply(Math, arr);
console.log(max, min);
</code></pre>
        <h4 id="bind-">bind()方法（绑定，捆绑）</h4>
        <ol>
          <li>
            <p>不会调用函数</p>
          </li>
          <li>
            <p>可以改变函数内部的 this 指向</p>
          </li>
          <li>
            <p>返回的是原函数改变 this 之后产生的新函数</p>
          </li>
          <li>
            <p>如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</p>
          </li>
          <li>
            <p>应用场景:不调用函数,但是还想改变 this 指向</p>
          </li>
        </ol>
        <pre><code class="lang-js">var o = {
  name: &quot;andy&quot;,
};
function fn(a, b) {
  console.log(this);
  console.log(a + b);
}
var f = fn.bind(o, 1, 2);
//此处的f是bind返回的新函数
f(); //调用新函数  this指向的是对象o 参数使用逗号隔开
</code></pre>
        <h4 id="call-apply-bind-">call、apply、bind 三者的异同</h4>
        <ul>
          <li>
            <p>共同点 :</p>
            <ol>
              <li>都可以改变 this 指向</li>
              <li>都是只会被函数调用</li>
            </ol>
          </li>
          <li>
            <p>不同点:</p>
            <ol>
              <li>call 和 apply 会调用函数, 并且改变函数内部 this 指向.</li>
              <li>call 和 apply 传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递</li>
              <li>bind 不会调用函数, 可以改变函数内部 this 指向.</li>
            </ol>
          </li>
          <li>
            <p>应用场景</p>
            <ol>
              <li>call 经常做继承.</li>
              <li>apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</li>
              <li>bind 不调用函数,但是还想改变 this 指向. 比如改变定时器内部的 this 指向.</li>
            </ol>
          </li>
        </ul>
        <h2 id="-">严格模式</h2>
        <h3 id="-">什么是严格模式</h3>
        <h3 id="-">严格模式中的变化</h3>
        <h4 id="-">变量规定</h4>
        <ol>
          <li>变量名必须先声明再使用</li>
          <li>不能删除已声明变量</li>
        </ol>
        <h4 id="-this-">严格模式中 this 的指向问题</h4>
        <ol>
          <li>严格模式下全局作用域中函数中的 this 是 undefined</li>
          <li>严格模式下,如果 构造函数不加 new 调用, this 指向的是 undefined 如果给他赋值则 会报错.</li>
          <li>定时器 this 还是指向 window</li>
          <li>事件，对象指向调用者</li>
        </ol>
        <h4 id="-">函数变化</h4>
        <ol>
          <li>函数不能有重名的参数</li>
          <li>函数必须声明在顶层新版本的 JavaScript 会引入‘块级作用域’(Es6 中已经引入)。为与新函数接轨，不允许在非函数的代码块内声明函数。</li>
        </ol>
        <h2 id="-">高阶函数</h2>
        <p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p>
        <h2 id="-">闭包</h2>
        <h3 id="-">变量的作用域复习</h3>
        <h3 id="-">什么是闭包</h3>
        <p><code>闭包（closure）指有权访问另一个函数作用域中变量的函数。</code>简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</p>
        <pre><code class="lang-js">// 闭包（closure）指有权访问另一个函数作用域中变量的函数。
// 闭包: 我们fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num
function fn() {
  var num = 10;
  function fun() {
    console.log(num);
  }
  fun();
}
fn();
</code></pre>
        <h4 id="-">闭包的作用</h4>
        <p>闭包的作用：<code>延伸了变量的作用范围</code></p>
        <pre><code class="lang-js">function fn() {
  var num = 250;
  function fun() {
    console.log(num);
  }
  return fun;
  // return function () {
  //     console.log(num);
  //   };
}
var f = fn();
f();
</code></pre>
        <h4 id="-">闭包的案例</h4>
        <ol>
          <li>利用闭包的方式得到当前 li 的索引号</li>
        </ol>
        <pre><code class="lang-js">for (var i = 0; i &lt; lis.length; i++) {
  // 利用for循环创建了4个立即执行函数
  // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量
  (function (i) {
    lis[i].onclick = function () {
      console.log(i);
    };
  })(i);
}
</code></pre>
        <ol start="2">
          <li>闭包应用-3 秒钟之后,打印所有 li 元素的内容</li>
        </ol>
        <pre><code class="lang-js">for (var i = 0; i &lt; lis.length; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(lis[i].innerHTML);
    }, 3000);
  })(i);
}
</code></pre>
        <ol start="3">
          <li>闭包应用-计算打车价格</li>
        </ol>
        <pre><code class="lang-js">/*需求分析
打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格
如果有拥堵情况,总价格多收取10块钱拥堵费*/

var car = (function () {
  var start = 13; // 起步价  局部变量
  var total = 0; // 总价  局部变量
  return {
    // 正常的总价
    price: function (n) {
      if (n &lt;= 3) {
        total = start;
      } else {
        total = start + (n - 3) * 5;
      }
      return total;
    },
    // 拥堵之后的费用
    yd: function (flag) {
      return flag ? total + 10 : total;
    },
  };
})();
console.log(car.price(5)); // 23
console.log(car.yd(true)); // 33
</code></pre>
        <h2 id="-">递归函数</h2>
        <h3 id="-">什么是递归函数</h3>
        <p>理解:<code>函数内部自己调用自己.</code>这个函数就是递归函数</p>
        <h2 id="-">正则表达式概述</h2>
        <h3 id="-">什么是正则表达式</h3>
        <p><code>正则表达式（ Regular Expression ）</code>是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。</p>
        <p>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线，
          昵称输入框中可以输入中文(<code>匹配</code>)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(<code>替换</code>)，或从字符串中获取我们想要的特定部分(<code>提取</code>等 。
        </p>
        <h3 id="-">正则表达式的特点</h3>
        <ol>
          <li>灵活性、逻辑性和功能性非常的强。</li>
          <li>可以迅速地用极简单的方式达到字符串的复杂控制。</li>
          <li>难懂</li>
        </ol>
        <h2 id="-js-">正则表达式在 js 中的使用</h2>
        <h3 id="-">正则表达式的创建</h3>
        <ol>
          <li>
            <p>通过调用 RegExp 对象的构造函数创建</p>
            <pre><code class="lang-js">//RegExp是Regular Expression 简写
var regexp = new RegExp(自变量);
var regexp = new RegExp(/123/);
console.log(regexp); //123
</code></pre>
          </li>
          <li>
            <p>利用字面量创建 正则表达式</p>
            <pre><code class="lang-js">var rg = /123/;
</code></pre>
          </li>
        </ol>
        <h3 id="-test">检测正则表达式 test</h3>
        <p>test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。</p>
        <pre><code class="lang-js">var rg = /123/;
console.log(rg.test(123)); //匹配字符中是否出现123  出现结果为true
console.log(rg.test(&quot;abc&quot;)); //匹配字符中是否出现123 未出现结果为false
</code></pre>
        <h2 id="-">正则表达式中的特殊字符</h2>
        <p>### </p>
        <h3 id="-">边界符</h3>
        <p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p>
        <table>
          <thead>
            <tr>
              <th>边界符</th>
              <th>说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>^</td>
              <td>表示匹配首行的文本（开始）</td>
            </tr>
            <tr>
              <td>$</td>
              <td>表示匹配行尾的文本（结束）</td>
            </tr>
          </tbody>
        </table>
        <h3 id="-">字符类</h3>
        <p>字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</p>
        <h4 id="-">[] 方括号</h4>
        <p>表示有一系列字符可供选择，只要匹配其中一个就可以了</p>
        <table>
          <thead>
            <tr>
              <th>举例</th>
              <th>说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>/[abc]/</td>
              <td>只要包含<code>有a 或者 包含有b 或者包含有c</code>都返回为 true</td>
            </tr>
            <tr>
              <td>/^[abc]$/</td>
              <td><code>三选一</code> 只有是 a 或者是 b 或者是 c 这三个字母才返回 true</td>
            </tr>
            <tr>
              <td>/^[a-z]$/</td>
              <td>26 个英文字母<code>任何一个字母</code>返回 true - 表示的是 a 到 z 的范围</td>
            </tr>
            <tr>
              <td>/^[a-zA-Z0-9_-]$/</td>
              <td>26 个英文字母(大写和小写都可以)<code>任何一个字母</code>返回 true</td>
            </tr>
            <tr>
              <td>/^[ <code>^</code> a-zA-Z0-9_-]$/</td>
              <td>如果中括号里面有^ 表示<code>取反</code>的意思 千万和 我们边界符 ^ 别混淆</td>
            </tr>
          </tbody>
        </table>
        <h4 id="-">量词符</h4>
        <p>量词符用来设定某个模式出现的次数。</p>
        <table>
          <thead>
            <tr>
              <th>量词</th>
              <th>举例</th>
              <th>说明（true）</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>*</td>
              <td>_/^a`<em>`$/\</em></td>
              <td>重复 0 次或更多次</td>
            </tr>
            <tr>
              <td>+</td>
              <td><em>/^a<code>+</code>$/</em></td>
              <td>重复 1 次或更多次</td>
            </tr>
            <tr>
              <td>?</td>
              <td><em>/^a<code>?</code>$/</em></td>
              <td>重复 0 次或 1 次</td>
            </tr>
            <tr>
              <td>{n}</td>
              <td><em>/^a<code>{3}</code>$/</em></td>
              <td>重复 n 次</td>
            </tr>
            <tr>
              <td>{n,}</td>
              <td>/^a<code>{3,}</code>$/</td>
              <td>重复 n 次或更多次</td>
            </tr>
            <tr>
              <td>{n,m}</td>
              <td>/^a<code>{3,16}</code>$/</td>
              <td>重复 n 到 m 次</td>
            </tr>
          </tbody>
        </table>
        <h4 id="-">表单验证</h4>
        <p>正则表达式应用场景</p>
        <pre><code class="lang-html">&lt;input type=&quot;text&quot; class=&quot;uname&quot; /&gt; &lt;span&gt;请输入用户名&lt;/span&gt;
&lt;script&gt;
  //  量词是设定某个模式出现的次数
  var reg = /^[a-zA-Z0-9_-]{6,16}$/; // 这个模式用户只能输入英文字母 数字 下划线 中划线
  var uname = document.querySelector(&quot;.uname&quot;);
  var span = document.querySelector(&quot;span&quot;);
  uname.onblur = function () {
    if (reg.test(this.value)) {
      console.log(&quot;正确的&quot;);
      span.className = &quot;right&quot;;
      span.innerHTML = &quot;用户名格式输入正确&quot;;
    } else {
      console.log(&quot;错误的&quot;);
      span.className = &quot;wrong&quot;;
      span.innerHTML = &quot;用户名格式输入不正确&quot;;
    }
  };
&lt;/script&gt;
</code></pre>
        <h4 id="-">括号总结</h4>
        <p>1.大括号 量词符. 里面表示重复次数</p>
        <p>2.中括号 字符集合。匹配方括号中的任意字符. </p>
        <p>3.小括号表示优先级</p>
        <h3 id="-">预定义类</h3>
        <p>预定义类指的是某些常见模式的简写方式.</p>
        <table>
          <thead>
            <tr>
              <th>预定类</th>
              <th>说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>\d</td>
              <td>匹配 0-9 之间的任一数字，相当于[0-9]</td>
            </tr>
            <tr>
              <td>\D</td>
              <td>匹配 0-9 以外的字符，相当于[<code>^</code>0-9]</td>
            </tr>
            <tr>
              <td>\w</td>
              <td>匹配任意的字母，数字和下划线，相当于[A-Za-z0-9_]</td>
            </tr>
            <tr>
              <td>\W</td>
              <td>除所有字母数字和下划线以外的字符，相当于[<code>^</code>A-Za-z0-9_]</td>
            </tr>
            <tr>
              <td>\s</td>
              <td>匹配空格（宝库换行符，制表符，空格符等），相当于[\t\r\n\v\f]</td>
            </tr>
            <tr>
              <td>\S</td>
              <td>匹配非空格的字符，相当于[<code>^</code>\t\r\v\n\f]</td>
            </tr>
          </tbody>
        </table>
        <h3 id="-replace">正则替换 replace</h3>
        <p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式</p>
        <pre><code class="lang-js">var str = &#39;andy和red&#39;;
var newStr = str.replace(&#39;andy&#39;, &#39;baby&#39;);
console.log(newStr)//baby和red
//等同于 此处的andy可以写在正则表达式内
var newStr2 = str.replace(/andy/, &#39;baby&#39;);
console.log(newStr2)//baby和red
//全部替换
var str = &#39;abcabc&#39;
var nStr = str.replace(/a/,&#39;哈哈&#39;)
console.log(nStr) //哈哈bcabc
//全部替换g
var nStr = str.replace(/a/a,&#39;哈哈&#39;)
console.log(nStr) //哈哈bc哈哈bc
//忽略大小写i
var str = &#39;aAbcAba&#39;;
var newStr = str.replace(/a/gi,&#39;哈哈&#39;)//&quot;哈哈哈哈bc哈哈b哈哈&quot;
</code></pre>
        <p><strong>案例:过滤敏感词汇</strong></p>
        <pre><code class="lang-html">&lt;textarea name=&quot;&quot; id=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;button&gt;提交&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
    var text = document.querySelector(&#39;textarea&#39;);
    var btn = document.querySelector(&#39;button&#39;);
    var div = document.querySelector(&#39;div&#39;);
    btn.onclick = function() {
        div.innerHTML = text.value.replace(/激情|gay/g, &#39;**&#39;);
    }
&lt;/script&gt;

</code></pre>
        <h2 id="-">变量声明相关</h2>
        <p>问题：</p>
        <ol>
          <li>
            <p>let的作用?有何特性? </p>
          </li>
          <li>
            <p>const的作用？有何特性 </p>
          </li>
          <li>let const var关键字区别?</li>
        </ol>
        <p>回答:</p>
        <ol>
          <li>定义变量 特性 具备块级作用域 没有变量提升 存在暂时性死区现象</li>
          <li>定义常量 具备块级作用域 必须声明时就赋值</li>
          <li>const定义常量(初次赋值后不能重新赋值) let及var定义变量，const及let具备块级作用域，var没有，const及let不存在常量/变量提升，var 存在变量提升现象</li>
        </ol>
        <pre><code class="lang-js">面试题:
let arr = [];
for (let i = 0; i &lt; 2; i++) {
     arr[i] = function () {
         console.log(i); 
     }
}
arr[0]();  //0
arr[1]();  //1

var arr=[]
for(let i=0;i&lt;2;i++){
    arr[i]=function(){
        i+=3
        console.log(i);
    }
}
arr[0]()  //3
arr[1]()  //4

var arr=[]
for(var i=0;i&lt;2;i++){
    arr[i]=function(){
        i+=3
        console.log(i);
    }
}
arr[0]()  //5
arr[1]()  //8
</code></pre>
        <table>
          <thead>
            <tr>
              <th>var</th>
              <th>let</th>
              <th>const</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>函数作用域</td>
              <td>块级作用域</td>
              <td>块级作用域</td>
            </tr>
            <tr>
              <td>会变量提升</td>
              <td>无变量提升</td>
              <td>无变量提升</td>
            </tr>
            <tr>
              <td>无暂时性死区现象</td>
              <td>存在暂时性死区</td>
              <td>存在暂时性死区</td>
            </tr>
            <tr>
              <td>值可变化</td>
              <td>值可变化</td>
              <td>值不可变化</td>
            </tr>
            <tr>
              <td>声明时可不赋值</td>
              <td>声明时可不赋值</td>
              <td>必须声明时赋值</td>
            </tr>
            <tr>
              <td>可重复声明</td>
              <td>不可重复声明</td>
              <td>不可重复声明</td>
            </tr>
          </tbody>
        </table>
        <h2 id="-">解构赋值</h2>
        <p>问题:</p>
        <p>1 解构赋值有什么好处?</p>
        <p>2 有几种解构赋值的方式？</p>
        <p>答:</p>
        <p>1 让变量赋值更简洁</p>
        <p>2 两种 数组解构 对象解构</p>
        <pre><code class="lang-js">// 数组解构
let [a,b,c] = [1,2,3]
console.log(a,b,c) // 1,2,3
// 对象解构
let {a,b,c} = {a:1,b:2}
console.log(a,b,c) // 1,2,undefined
let {a:hello,b:hi,c} = {a:1,b:2}
console.log(hello,hi) // 1,2
</code></pre>
        <h2 id="-">函数相关</h2>
        <p>问题:</p>
        <ol>
          <li>箭头函数有什么好处?和普通函数有何不同？</li>
          <li>剩余参数和扩展运算符有何区别？</li>
        </ol>
        <p>答:</p>
        <ol>
          <li>:箭头函数更简洁,和普通函数区别:没有自己的this和arguments</li>
          <li>剩余参数是将用,连接的数据转成数组，而扩展运算符是将数组或伪数组转换成用逗号连接的数据，扩展运算符可视为剩余参数的反操作</li>
        </ol>
        <pre><code class="lang-js">// 箭头函数
const fn = (形参列表)=&gt;{函数体}
当只有一个形参时()可省略,当函数体只有一句代码时{}也可省略
// 剩余参数
const fn = (...args)=&gt;{console.log(args)}
fn(1,3,5,7) // [1,3,5,7]
// 剩余参数对传统方式定义函数也有效,剩余参数仅能作为形参列表中的最后一个参数
// 剩余参数与结构赋值结合
// 剩余参数应用场景:1 形参  2 解构赋值
let [a,...b]=[1,2,3,4]
console.log(a,b)//1 [2,3,4]
// 扩展运算符
var x = [1,2,3]
console.log(...x) // 1 2 3  相当于console.log(1,2,3)
// 注意:扩展运算符通常用于实参中，而剩余参数通常用作形参
// 扩展运算符的应用:1 将伪数组变为真数组  2 连接多个数组  3 实参
var divs = document.querySelectorAll(&#39;div&#39;);
var divsArr = [...divs]
var arr1 = [1,2,3],arr2 = [4,5,6];
var arr3 = arr1.push(...arr2)
</code></pre>
        <h2 id="-">内置对象相关</h2>
        <h3 id="-">数组相关</h3>
        <table>
          <thead>
            <tr>
              <th>方法</th>
              <th>作用</th>
              <th>使用</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Array.from()</td>
              <td>将伪数组(属性名为0,1,..,还有length属性)转化为真数组</td>
              <td>Array.from(arguments)</td>
            </tr>
            <tr>
              <td>数组实例.find()</td>
              <td>在数组中查找第一个符合条件的元素</td>
              <td>[1,2,3].find(ele=&gt;ele&gt;2)</td>
            </tr>
            <tr>
              <td>数组实例.findIndex()</td>
              <td>在数组中查找第一个符合条件的元素的下标，找不到返回-1</td>
              <td>[1,2,3].findIndex(ele=&gt;ele&gt;2)</td>
            </tr>
            <tr>
              <td>数组实例.includes()</td>
              <td>判断数组中是否存在某个元素</td>
              <td>[1,2,3].includes(4)</td>
            </tr>
          </tbody>
        </table>
        <pre><code class="lang-js">// es6新增遍历数组的结构 for...of 直接遍历数组的每个元素
let arr = [3,4,5]
for(var o of arr){
    console.log(o) // 3 4 5
}
</code></pre>
        <h3 id="-">字符串相关</h3>
        <h4 id="-">模板字符串语法</h4>
        <pre><code class="lang-js">//使用方法  let str = `xxxx....${表达式}yyy`
//模板字符串的特点:
// 1 换行不报错且输出时保留换行
// 2 可方便地嵌入表达式，包含 变量、函数调用、三元表达式等等
</code></pre>
        <h4 id="-">相关方法</h4>
        <table>
          <thead>
            <tr>
              <th>方法名</th>
              <th>作用</th>
              <th>使用</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>字符串.startsWith()</td>
              <td>判断是否以某个字符串开头</td>
              <td>&#39;Hello&#39;.startsWith(&#39;He&#39;) //true</td>
            </tr>
            <tr>
              <td>字符串.endsWith()</td>
              <td>判断是否以某个字符串结尾</td>
              <td>&#39;World&#39;.endsWith(&#39;ld&#39;)//true</td>
            </tr>
            <tr>
              <td>字符串.repeat()</td>
              <td>将某个字符串重复n次，得到新字符串</td>
              <td>&#39;12&#39;.repeat(2) // 1212</td>
            </tr>
          </tbody>
        </table>
        <h3 id="-">新增数据结构</h3>
        <h4 id="set">Set</h4>
        <p><code>set对象用于存放一组不重复的数据,new Set([1,2,1])得到set对象，可传入一个数组作实参</code></p>
        <table>
          <thead>
            <tr>
              <th>方法名</th>
              <th>作用</th>
              <th>备注</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>add()</td>
              <td>往set对象中新增一个数据,返回当前set对象</td>
              <td></td>
            </tr>
            <tr>
              <td>delete()</td>
              <td>删除set对象中的某条数据</td>
              <td></td>
            </tr>
            <tr>
              <td>clear()</td>
              <td>清空set对象</td>
              <td></td>
            </tr>
            <tr>
              <td>has()</td>
              <td>判断set对象中是否有某个数据,有返回true,否则false</td>
              <td></td>
            </tr>
            <tr>
              <td>forEach()</td>
              <td>遍历set对象</td>
              <td></td>
            </tr>
            <tr>
              <td>size</td>
              <td>属性，获取set对象数据长度</td>
            </tr>
          </tbody>
        </table>
        <h4 id="map">map</h4>
        <p><code>map对象存放一组键值对，其中键可以为更丰富的数据类型,普通js对象的键只能为字符串或数字,</code></p>
        <p><code>new Map([[&#39;name&#39;, &#39;张三&#39;],[[&#39;grade&#39;,&#39;class&#39;], [1,3]]])</code></p>
        <table>
          <thead>
            <tr>
              <th>方法名</th>
              <th>作用</th>
              <th>备注</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>set()</td>
              <td>增加键值对</td>
              <td></td>
            </tr>
            <tr>
              <td>get()</td>
              <td>获取某个键对应的值</td>
              <td></td>
            </tr>
            <tr>
              <td>has()</td>
              <td>判断某个键是否存在</td>
              <td></td>
            </tr>
            <tr>
              <td>delete()</td>
              <td>删除某个键值对</td>
              <td></td>
            </tr>
            <tr>
              <td>clear()</td>
              <td>清空</td>
              <td></td>
            </tr>
            <tr>
              <td>size</td>
              <td>属性，获取键值对个数</td>
              <td></td>
            </tr>
            <tr>
              <td>keys()</td>
              <td>获取所有的键</td>
              <td>静态方法</td>
            </tr>
            <tr>
              <td>values()</td>
              <td>获取所有的值</td>
              <td>静态方法</td>
            </tr>
            <tr>
              <td>entries()</td>
              <td>获取所有的键以及值</td>
              <td>静态方法</td>
            </tr>
            <tr>
              <td>forEach()</td>
              <td>遍历所有键值对</td>
            </tr>
          </tbody>
        </table>
        <pre><code class="lang-js">//经典面试题
var obj = {},obj1={a:1},o={};
o[obj]=10;
o[obj1]=20
console.log(o)//{[object Object]:20} 因js对象的属性名只能是字符串或数字，用对象作为属性名时会发生隐式转换，默认调用toString()方法

var x;
if(x==1&amp;&amp;x==2&amp;&amp;x==3){
    alert(&#39;这也行?&#39;)
}
问：x为什么值时会执行if中的alert语句
当x={x:1,toString:function(){return this.x++}} 时
解答:对象 和 number型数据做 比较运算时，默认是没有意义的，为了能比较，js默认会将对象做隐式转换,转换规则为对象调用自己的toString(),以返回值 来和 number型数据比较.
</code></pre>

      </article>
    </div>
  </div>
</body>

</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript">

  $(document).ready(function () {
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts);
    $('#tree').ztree_toc(conf);
  });
</SCRIPT>